<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>欢迎回来</title><meta name="author" content="一日三餐"><meta name="copyright" content="一日三餐"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="我的日常积累">
<meta property="og:type" content="website">
<meta property="og:title" content="欢迎回来">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="欢迎回来">
<meta property="og:description" content="我的日常积累">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/yatou.jpg">
<meta property="article:author" content="一日三餐">
<meta property="article:tag" content="编程技术，算法，java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/yatou.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/page/2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '欢迎回来',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-04-21 22:16:20'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="欢迎回来" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/yatou.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('https://s2.loli.net/2024/04/21/M9qDXPUflRcbKAw.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="欢迎回来"><span class="site-name">欢迎回来</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">欢迎回来</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://blog.csdn.net/weixin_62647396?type=blog" target="_blank" title="CSDN"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/y_ma@siat.ac.cn" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/2024/04/20/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/" title="创建线程的几种方式"><img class="post-bg" src="/img/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="创建线程的几种方式"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/04/20/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/" title="创建线程的几种方式">创建线程的几种方式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-20T08:30:08.282Z" title="发表于 2024-04-20 16:30:08">2024-04-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%B9%B6%E5%8F%91/">并发</a></span></div><div class="content">面试官：“创建线程有哪几种常见的方式？”
继承 Thread 类
实现 Runnable 接口
使用 Executor 框架
使用 FutureTask

最简单的两种方式1.继承 Thread 类2.实现 Runnable 接口比较实用的两种方式3.使用 Executor 框架Executor 框架是 Java5 之后引进的，在 Java 5 之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。

补充：this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。

Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架让并发编程变得更加简单。
为了能搞懂如何使用 Executor 框架创建
Executor 框架结构(主要由三大部分组成)1) 任务(Runnable &#x2F;Callable)执行任务需要实现的 Runnable 接口  ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/04/20/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93/" title="并发容器总结"><img class="post-bg" src="/img/9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="并发容器总结"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/04/20/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93/" title="并发容器总结">并发容器总结</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-20T08:30:08.279Z" title="发表于 2024-04-20 16:30:08">2024-04-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%B9%B6%E5%8F%91/">并发</a></span></div><div class="content">


一 JDK 提供的并发容器总结
二 ConcurrentHashMap
三 CopyOnWriteArrayList
3.1 CopyOnWriteArrayList 简介
3.2 CopyOnWriteArrayList 是如何做到的？
3.3 CopyOnWriteArrayList 读取和写入源码简单分析
3.3.1 CopyOnWriteArrayList 读取操作的实现
3.3.2 CopyOnWriteArrayList 写入操作的实现




四 ConcurrentLinkedQueue
五 BlockingQueue
5.1 BlockingQueue 简单介绍
5.2 ArrayBlockingQueue
5.3 LinkedBlockingQueue
5.4 PriorityBlockingQueue


六 ConcurrentSkipListMap
七 参考



一 JDK 提供的并发容器总结JDK 提供的这些容器大部分在 java.util.concurrent 包中。

ConcurrentHashMap: 线程安全的 HashMap
CopyOn ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/04/20/ThreadLocal%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89/" title="Threadlocal学习"><img class="post-bg" src="/img/9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Threadlocal学习"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/04/20/ThreadLocal%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89/" title="Threadlocal学习">Threadlocal学习</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-20T08:30:08.277Z" title="发表于 2024-04-20 16:30:08">2024-04-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%B9%B6%E5%8F%91/">并发</a></span></div><div class="content">ThreadLocal造成OOM内存溢出案例演示与原理分析
深入理解 Java 之 ThreadLocal 工作原理
ThreadLocalThreadLocal简介通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ JDK中提供的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。
如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get（） 和 set（） 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。
再举个简单的例子： 
比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来这两个线程竞争的。
Thr ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/04/20/synchronized%E5%9C%A8JDK1.6%E4%B9%8B%E5%90%8E%E7%9A%84%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96/" title="synchronized底层优化"><img class="post-bg" src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="synchronized底层优化"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/04/20/synchronized%E5%9C%A8JDK1.6%E4%B9%8B%E5%90%8E%E7%9A%84%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96/" title="synchronized底层优化">synchronized底层优化</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-20T08:30:08.273Z" title="发表于 2024-04-20 16:30:08">2024-04-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%B9%B6%E5%8F%91/">并发</a></span></div><div class="content">JDK1.6 对锁的实现引入了大量的优化来减少锁操作的开销，如: 偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化 等等技术。
锁主要存在四中状态，依次是：

无锁状态
偏向锁状态
轻量级锁状态
重量级锁状态

锁🔐会随着竞争的激烈而逐渐升级。
另外，需要注意：锁可以升级不可降级，即 无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁是单向的。 这种策略是为了提高获得锁和释放锁的效率。
偏向锁引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。
偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！（关于偏向锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。）
偏向锁的加锁当一个线程访问同步块并获取锁时, 会在锁对象的对象头和栈 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/04/20/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" title="线程学习"><img class="post-bg" src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程学习"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/04/20/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" title="线程学习">线程学习</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-20T08:30:08.271Z" title="发表于 2024-04-20 16:30:08">2024-04-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%B9%B6%E5%8F%91/">并发</a></span></div><div class="content">
一 使用线程池的好处
二 Executor 框架
2.1 简介
2.2 Executor 框架结构(主要由三大部分组成)
1) 任务(Runnable &#x2F;Callable)
2) 任务的执行(Executor)
3) 异步计算的结果(Future)


2.3 Executor 框架的使用示意图


三 (重要)ThreadPoolExecutor 类简单介绍
3.1 ThreadPoolExecutor 类分析
3.2 推荐使用 ThreadPoolExecutor 构造函数创建线程池


四 (重要)ThreadPoolExecutor 使用示例
4.1 示例代码:Runnable+ThreadPoolExecutor
4.2 线程池原理分析
4.3 几个常见的对比
4.3.1 Runnable vs Callable
4.3.2 execute() vs submit()
4.3.3 shutdown()VSshutdownNow()
4.3.2 isTerminated() VS isShutdown()


4.4 加餐:Callable+ThreadPoolEx ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/04/20/Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%80%BB%E7%BB%93/" title="原子类"><img class="post-bg" src="/img/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="原子类"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/04/20/Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%80%BB%E7%BB%93/" title="原子类">原子类</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-20T08:30:08.268Z" title="发表于 2024-04-20 16:30:08">2024-04-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%B9%B6%E5%8F%91/">并发</a></span></div><div class="content">


1 Atomic 原子类介绍
2 基本类型原子类
2.1 基本类型原子类介绍
2.2 AtomicInteger 常见方法使用
2.3 基本数据类型原子类的优势
2.4 AtomicInteger 线程安全原理简单分析


3 数组类型原子类
3.1 数组类型原子类介绍
3.2 AtomicIntegerArray 常见方法使用


4 引用类型原子类
4.1  引用类型原子类介绍
4.2 AtomicReference 类使用示例
4.3 AtomicStampedReference 类使用示例
4.4 AtomicMarkableReference 类使用示例


5 对象的属性修改类型原子类
5.1 对象的属性修改类型原子类介绍
5.2 AtomicIntegerFieldUpdater 类使用示例





1 Atomic 原子类介绍Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。
所 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/04/20/AQS%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AAQS%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E6%80%BB%E7%BB%93/" title="AQS学习资料"><img class="post-bg" src="/img/3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AQS学习资料"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/04/20/AQS%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AAQS%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E6%80%BB%E7%BB%93/" title="AQS学习资料">AQS学习资料</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-20T08:30:08.265Z" title="发表于 2024-04-20 16:30:08">2024-04-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%B9%B6%E5%8F%91/">并发</a></span></div><div class="content">
1 AQS 简单介绍
2 AQS 原理
2.1 AQS 原理概览
2.2 AQS 对资源的共享方式
2.3 AQS 底层使用了模板方法模式


3 Semaphore(信号量)-允许多个线程同时访问
4 CountDownLatch （倒计时器）
4.1 CountDownLatch 的三种典型用法
4.2 CountDownLatch 的使用示例
4.3 CountDownLatch 的不足
4.4 CountDownLatch 常见面试题


5 CyclicBarrier(循环栅栏)
5.1 CyclicBarrier 的应用场景
5.2 CyclicBarrier 的使用示例
5.3 CyclicBarrier源码分析
5.4 CyclicBarrier 和 CountDownLatch 的区别


6 ReentrantLock 和 ReentrantReadWriteLock
参考
公众号




常见问题：AQS 原理？;CountDownLatch 和 CyclicBarrier 了解吗,两者的区别是什么？用过 Semaphore 吗？

1 AQS 简单介绍AQS  ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/04/20/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="并发面试总结-进阶"><img class="post-bg" src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="并发面试总结-进阶"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/04/20/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="并发面试总结-进阶">并发面试总结-进阶</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-20T08:30:08.263Z" title="发表于 2024-04-20 16:30:08">2024-04-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="content">
Java 并发进阶常见面试题总结
1.synchronized 关键字
1.1.说一说自己对于 synchronized 关键字的了解
1.2. 说说自己是怎么使用 synchronized 关键字
1.3. 构造方法可以使用 synchronized 关键字修饰么？
1.3. 讲一下 synchronized 关键字的底层原理
1.3.1. synchronized 同步语句块的情况
1.3.2. synchronized 修饰方法的的情况
1.3.3.总结


1.4. 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗
1.5. 谈谈 synchronized 和 ReentrantLock 的区别
1.5.1. 两者都是可重入锁
1.5.2.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API
1.5.3.ReentrantLock 比 synchronized 增加了一些高级功能




2. volatile 关键字
2.1. CPU 缓存模型
2.2. 讲一下 JMM(Java 内 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/04/20/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="并发面试总结"><img class="post-bg" src="/img/10.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="并发面试总结"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/04/20/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="并发面试总结">并发面试总结</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-20T08:30:08.261Z" title="发表于 2024-04-20 16:30:08">2024-04-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="content">


Java 并发基础常见面试题总结
1. 什么是线程和进程?
1.1. 何为进程?
1.2. 何为线程?


2. 请简要描述线程与进程的关系,区别及优缺点？
2.1. 图解进程和线程的关系
2.2. 程序计数器为什么是私有的?
2.3. 虚拟机栈和本地方法栈为什么是私有的?
2.4. 一句话简单了解堆和方法区


3. 说说并发与并行的区别?
4. 为什么要使用多线程呢?
5. 使用多线程可能带来什么问题?
6. 说说线程的生命周期和状态?
7. 什么是上下文切换?
8. 什么是线程死锁?如何避免死锁?
8.1. 认识线程死锁
8.2. 如何避免线程死锁?


9. 说说 sleep() 方法和 wait() 方法区别和共同点?
10. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？
公众号





Java 并发基础常见面试题总结1. 什么是线程和进程?1.1. 何为进程?进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。
在 Java 中，当 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/04/19/%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/" title="锁升级过程">锁升级过程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-19T12:04:23.479Z" title="发表于 2024-04-19 20:04:23">2024-04-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span></div><div class="content">假如我们现在有一百个线程，商品A库存量为100，售出方法为sale()
在没有上锁是，即时我们设置当库存量为零时停止售卖，但是也极有可能出现超卖的情况，这是由于我们售卖的方法没有原子性，在售出的过程中，库存为零时，其他线程可能刚好调用方法，这时条件没有更改，所以是无法及时停止的。
synchronized关键字        使sale()方法一次最多服务一个线程，这样就解决了超卖的问题，此时涉及到锁升级过程
初始状态，线程A发过来请求，请求获取锁，此时sale()的对象锁处于空闲状态，获取成功，对象锁的对象头部分包含markword，用于记录当前获取锁的线程，此时为偏向锁，获取成功之后执行sql语句。

 线程A此时还在使用 sale()方法，也就是仍然占有这个锁，此时线程B过来了，也想要执行这个方法，那也需要获取这个锁，此时线程B将自己的线程ID与markword中记录的id进行对比，发现不同，那么锁升级为轻量级锁，线程B在旁边不断地CAS自旋尝试获取锁。

CAS不断地自旋其实是很消耗资源的，当线程B多次CAS仍然无法获取到锁的话，此时锁升级为重量级锁，线程B进入阻塞队列沉睡，等 ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/#content-inner">3</a><a class="extend next" rel="next" href="/page/3/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/yatou.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">一日三餐</div><div class="author-info__description">我的日常积累</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>前往个人信息</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://blog.csdn.net/weixin_62647396?type=blog" target="_blank" title="CSDN"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/y_ma@siat.ac.cn" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 一日三餐</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>window.typedJSFn = {
  init: (str) => {
    window.typed = new Typed('#subtitle', Object.assign({
      strings: str,
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50,
    }, null))
  },
  run: (subtitleType) => {
    if (true) {
      if (typeof Typed === 'function') {
        subtitleType()
      } else {
        getScript('https://cdn.jsdelivr.net/npm/typed.js@2.1.0/dist/typed.umd.min.js').then(subtitleType)
      }
    } else {
      subtitleType()
    }
  }
}
</script><script>function subtitleType () {
  getScript('https://sdk.jinrishici.com/v2/browser/jinrishici.js').then(() => {
    jinrishici.load(result =>{
      if (true) {
        const sub = []
        const content = result.data.content
        sub.unshift(content)
        typedJSFn.init(sub)
      } else {
        document.getElementById('subtitle').textContent = result.data.content
      }
    })
  })
}
typedJSFn.run(subtitleType)
</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>